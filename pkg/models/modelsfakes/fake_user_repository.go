// Code generated by counterfeiter. DO NOT EDIT.
package modelsfakes

import (
	"sync"

	"github.com/google/uuid"
	"github.com/jcorry/morellis/pkg/models"
)

type FakeUserRepository struct {
	AddIngredientStub        func(int64, *models.Ingredient, string) (*models.UserIngredient, error)
	addIngredientMutex       sync.RWMutex
	addIngredientArgsForCall []struct {
		arg1 int64
		arg2 *models.Ingredient
		arg3 string
	}
	addIngredientReturns struct {
		result1 *models.UserIngredient
		result2 error
	}
	addIngredientReturnsOnCall map[int]struct {
		result1 *models.UserIngredient
		result2 error
	}
	AddPermissionStub        func(int, models.Permission) (int, error)
	addPermissionMutex       sync.RWMutex
	addPermissionArgsForCall []struct {
		arg1 int
		arg2 models.Permission
	}
	addPermissionReturns struct {
		result1 int
		result2 error
	}
	addPermissionReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	CountStub        func() int
	countMutex       sync.RWMutex
	countArgsForCall []struct {
	}
	countReturns struct {
		result1 int
	}
	countReturnsOnCall map[int]struct {
		result1 int
	}
	DeleteStub        func(int) (bool, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 int
	}
	deleteReturns struct {
		result1 bool
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetStub        func(int) (*models.User, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 int
	}
	getReturns struct {
		result1 *models.User
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	GetByAuthTokenStub        func(string) (*models.User, error)
	getByAuthTokenMutex       sync.RWMutex
	getByAuthTokenArgsForCall []struct {
		arg1 string
	}
	getByAuthTokenReturns struct {
		result1 *models.User
		result2 error
	}
	getByAuthTokenReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	GetByCredentialsStub        func(models.Credentials) (*models.User, error)
	getByCredentialsMutex       sync.RWMutex
	getByCredentialsArgsForCall []struct {
		arg1 models.Credentials
	}
	getByCredentialsReturns struct {
		result1 *models.User
		result2 error
	}
	getByCredentialsReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	GetByPhoneStub        func(string) (*models.User, error)
	getByPhoneMutex       sync.RWMutex
	getByPhoneArgsForCall []struct {
		arg1 string
	}
	getByPhoneReturns struct {
		result1 *models.User
		result2 error
	}
	getByPhoneReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	GetByUUIDStub        func(uuid.UUID) (*models.User, error)
	getByUUIDMutex       sync.RWMutex
	getByUUIDArgsForCall []struct {
		arg1 uuid.UUID
	}
	getByUUIDReturns struct {
		result1 *models.User
		result2 error
	}
	getByUUIDReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	GetIngredientsStub        func(int64) ([]*models.UserIngredient, error)
	getIngredientsMutex       sync.RWMutex
	getIngredientsArgsForCall []struct {
		arg1 int64
	}
	getIngredientsReturns struct {
		result1 []*models.UserIngredient
		result2 error
	}
	getIngredientsReturnsOnCall map[int]struct {
		result1 []*models.UserIngredient
		result2 error
	}
	GetPermissionsStub        func(int) ([]models.UserPermission, error)
	getPermissionsMutex       sync.RWMutex
	getPermissionsArgsForCall []struct {
		arg1 int
	}
	getPermissionsReturns struct {
		result1 []models.UserPermission
		result2 error
	}
	getPermissionsReturnsOnCall map[int]struct {
		result1 []models.UserPermission
		result2 error
	}
	InsertStub        func(uuid.UUID, models.NullString, models.NullString, models.NullString, string, int, string) (*models.User, error)
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		arg1 uuid.UUID
		arg2 models.NullString
		arg3 models.NullString
		arg4 models.NullString
		arg5 string
		arg6 int
		arg7 string
	}
	insertReturns struct {
		result1 *models.User
		result2 error
	}
	insertReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	ListStub        func(int, int, string) ([]*models.User, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 string
	}
	listReturns struct {
		result1 []*models.User
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 []*models.User
		result2 error
	}
	RemoveAllPermissionsStub        func(int) error
	removeAllPermissionsMutex       sync.RWMutex
	removeAllPermissionsArgsForCall []struct {
		arg1 int
	}
	removeAllPermissionsReturns struct {
		result1 error
	}
	removeAllPermissionsReturnsOnCall map[int]struct {
		result1 error
	}
	RemovePermissionStub        func(int) (bool, error)
	removePermissionMutex       sync.RWMutex
	removePermissionArgsForCall []struct {
		arg1 int
	}
	removePermissionReturns struct {
		result1 bool
		result2 error
	}
	removePermissionReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RemoveUserIngredientStub        func(int64) error
	removeUserIngredientMutex       sync.RWMutex
	removeUserIngredientArgsForCall []struct {
		arg1 int64
	}
	removeUserIngredientReturns struct {
		result1 error
	}
	removeUserIngredientReturnsOnCall map[int]struct {
		result1 error
	}
	SaveAuthTokenStub        func(string, int) error
	saveAuthTokenMutex       sync.RWMutex
	saveAuthTokenArgsForCall []struct {
		arg1 string
		arg2 int
	}
	saveAuthTokenReturns struct {
		result1 error
	}
	saveAuthTokenReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateStub        func(*models.User) (*models.User, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *models.User
	}
	updateReturns struct {
		result1 *models.User
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *models.User
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserRepository) AddIngredient(arg1 int64, arg2 *models.Ingredient, arg3 string) (*models.UserIngredient, error) {
	fake.addIngredientMutex.Lock()
	ret, specificReturn := fake.addIngredientReturnsOnCall[len(fake.addIngredientArgsForCall)]
	fake.addIngredientArgsForCall = append(fake.addIngredientArgsForCall, struct {
		arg1 int64
		arg2 *models.Ingredient
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddIngredient", []interface{}{arg1, arg2, arg3})
	fake.addIngredientMutex.Unlock()
	if fake.AddIngredientStub != nil {
		return fake.AddIngredientStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addIngredientReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) AddIngredientCallCount() int {
	fake.addIngredientMutex.RLock()
	defer fake.addIngredientMutex.RUnlock()
	return len(fake.addIngredientArgsForCall)
}

func (fake *FakeUserRepository) AddIngredientCalls(stub func(int64, *models.Ingredient, string) (*models.UserIngredient, error)) {
	fake.addIngredientMutex.Lock()
	defer fake.addIngredientMutex.Unlock()
	fake.AddIngredientStub = stub
}

func (fake *FakeUserRepository) AddIngredientArgsForCall(i int) (int64, *models.Ingredient, string) {
	fake.addIngredientMutex.RLock()
	defer fake.addIngredientMutex.RUnlock()
	argsForCall := fake.addIngredientArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) AddIngredientReturns(result1 *models.UserIngredient, result2 error) {
	fake.addIngredientMutex.Lock()
	defer fake.addIngredientMutex.Unlock()
	fake.AddIngredientStub = nil
	fake.addIngredientReturns = struct {
		result1 *models.UserIngredient
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) AddIngredientReturnsOnCall(i int, result1 *models.UserIngredient, result2 error) {
	fake.addIngredientMutex.Lock()
	defer fake.addIngredientMutex.Unlock()
	fake.AddIngredientStub = nil
	if fake.addIngredientReturnsOnCall == nil {
		fake.addIngredientReturnsOnCall = make(map[int]struct {
			result1 *models.UserIngredient
			result2 error
		})
	}
	fake.addIngredientReturnsOnCall[i] = struct {
		result1 *models.UserIngredient
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) AddPermission(arg1 int, arg2 models.Permission) (int, error) {
	fake.addPermissionMutex.Lock()
	ret, specificReturn := fake.addPermissionReturnsOnCall[len(fake.addPermissionArgsForCall)]
	fake.addPermissionArgsForCall = append(fake.addPermissionArgsForCall, struct {
		arg1 int
		arg2 models.Permission
	}{arg1, arg2})
	fake.recordInvocation("AddPermission", []interface{}{arg1, arg2})
	fake.addPermissionMutex.Unlock()
	if fake.AddPermissionStub != nil {
		return fake.AddPermissionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.addPermissionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) AddPermissionCallCount() int {
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	return len(fake.addPermissionArgsForCall)
}

func (fake *FakeUserRepository) AddPermissionCalls(stub func(int, models.Permission) (int, error)) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = stub
}

func (fake *FakeUserRepository) AddPermissionArgsForCall(i int) (int, models.Permission) {
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	argsForCall := fake.addPermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) AddPermissionReturns(result1 int, result2 error) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = nil
	fake.addPermissionReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) AddPermissionReturnsOnCall(i int, result1 int, result2 error) {
	fake.addPermissionMutex.Lock()
	defer fake.addPermissionMutex.Unlock()
	fake.AddPermissionStub = nil
	if fake.addPermissionReturnsOnCall == nil {
		fake.addPermissionReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.addPermissionReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) Count() int {
	fake.countMutex.Lock()
	ret, specificReturn := fake.countReturnsOnCall[len(fake.countArgsForCall)]
	fake.countArgsForCall = append(fake.countArgsForCall, struct {
	}{})
	fake.recordInvocation("Count", []interface{}{})
	fake.countMutex.Unlock()
	if fake.CountStub != nil {
		return fake.CountStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.countReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) CountCallCount() int {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return len(fake.countArgsForCall)
}

func (fake *FakeUserRepository) CountCalls(stub func() int) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = stub
}

func (fake *FakeUserRepository) CountReturns(result1 int) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = nil
	fake.countReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeUserRepository) CountReturnsOnCall(i int, result1 int) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = nil
	if fake.countReturnsOnCall == nil {
		fake.countReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.countReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeUserRepository) Delete(arg1 int) (bool, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Delete", []interface{}{arg1})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeUserRepository) DeleteCalls(stub func(int) (bool, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeUserRepository) DeleteArgsForCall(i int) int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) DeleteReturns(result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) DeleteReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) Get(arg1 int) (*models.User, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeUserRepository) GetCalls(stub func(int) (*models.User, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeUserRepository) GetArgsForCall(i int) int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetReturns(result1 *models.User, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByAuthToken(arg1 string) (*models.User, error) {
	fake.getByAuthTokenMutex.Lock()
	ret, specificReturn := fake.getByAuthTokenReturnsOnCall[len(fake.getByAuthTokenArgsForCall)]
	fake.getByAuthTokenArgsForCall = append(fake.getByAuthTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetByAuthToken", []interface{}{arg1})
	fake.getByAuthTokenMutex.Unlock()
	if fake.GetByAuthTokenStub != nil {
		return fake.GetByAuthTokenStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getByAuthTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetByAuthTokenCallCount() int {
	fake.getByAuthTokenMutex.RLock()
	defer fake.getByAuthTokenMutex.RUnlock()
	return len(fake.getByAuthTokenArgsForCall)
}

func (fake *FakeUserRepository) GetByAuthTokenCalls(stub func(string) (*models.User, error)) {
	fake.getByAuthTokenMutex.Lock()
	defer fake.getByAuthTokenMutex.Unlock()
	fake.GetByAuthTokenStub = stub
}

func (fake *FakeUserRepository) GetByAuthTokenArgsForCall(i int) string {
	fake.getByAuthTokenMutex.RLock()
	defer fake.getByAuthTokenMutex.RUnlock()
	argsForCall := fake.getByAuthTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetByAuthTokenReturns(result1 *models.User, result2 error) {
	fake.getByAuthTokenMutex.Lock()
	defer fake.getByAuthTokenMutex.Unlock()
	fake.GetByAuthTokenStub = nil
	fake.getByAuthTokenReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByAuthTokenReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.getByAuthTokenMutex.Lock()
	defer fake.getByAuthTokenMutex.Unlock()
	fake.GetByAuthTokenStub = nil
	if fake.getByAuthTokenReturnsOnCall == nil {
		fake.getByAuthTokenReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.getByAuthTokenReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByCredentials(arg1 models.Credentials) (*models.User, error) {
	fake.getByCredentialsMutex.Lock()
	ret, specificReturn := fake.getByCredentialsReturnsOnCall[len(fake.getByCredentialsArgsForCall)]
	fake.getByCredentialsArgsForCall = append(fake.getByCredentialsArgsForCall, struct {
		arg1 models.Credentials
	}{arg1})
	fake.recordInvocation("GetByCredentials", []interface{}{arg1})
	fake.getByCredentialsMutex.Unlock()
	if fake.GetByCredentialsStub != nil {
		return fake.GetByCredentialsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getByCredentialsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetByCredentialsCallCount() int {
	fake.getByCredentialsMutex.RLock()
	defer fake.getByCredentialsMutex.RUnlock()
	return len(fake.getByCredentialsArgsForCall)
}

func (fake *FakeUserRepository) GetByCredentialsCalls(stub func(models.Credentials) (*models.User, error)) {
	fake.getByCredentialsMutex.Lock()
	defer fake.getByCredentialsMutex.Unlock()
	fake.GetByCredentialsStub = stub
}

func (fake *FakeUserRepository) GetByCredentialsArgsForCall(i int) models.Credentials {
	fake.getByCredentialsMutex.RLock()
	defer fake.getByCredentialsMutex.RUnlock()
	argsForCall := fake.getByCredentialsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetByCredentialsReturns(result1 *models.User, result2 error) {
	fake.getByCredentialsMutex.Lock()
	defer fake.getByCredentialsMutex.Unlock()
	fake.GetByCredentialsStub = nil
	fake.getByCredentialsReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByCredentialsReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.getByCredentialsMutex.Lock()
	defer fake.getByCredentialsMutex.Unlock()
	fake.GetByCredentialsStub = nil
	if fake.getByCredentialsReturnsOnCall == nil {
		fake.getByCredentialsReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.getByCredentialsReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByPhone(arg1 string) (*models.User, error) {
	fake.getByPhoneMutex.Lock()
	ret, specificReturn := fake.getByPhoneReturnsOnCall[len(fake.getByPhoneArgsForCall)]
	fake.getByPhoneArgsForCall = append(fake.getByPhoneArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetByPhone", []interface{}{arg1})
	fake.getByPhoneMutex.Unlock()
	if fake.GetByPhoneStub != nil {
		return fake.GetByPhoneStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getByPhoneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetByPhoneCallCount() int {
	fake.getByPhoneMutex.RLock()
	defer fake.getByPhoneMutex.RUnlock()
	return len(fake.getByPhoneArgsForCall)
}

func (fake *FakeUserRepository) GetByPhoneCalls(stub func(string) (*models.User, error)) {
	fake.getByPhoneMutex.Lock()
	defer fake.getByPhoneMutex.Unlock()
	fake.GetByPhoneStub = stub
}

func (fake *FakeUserRepository) GetByPhoneArgsForCall(i int) string {
	fake.getByPhoneMutex.RLock()
	defer fake.getByPhoneMutex.RUnlock()
	argsForCall := fake.getByPhoneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetByPhoneReturns(result1 *models.User, result2 error) {
	fake.getByPhoneMutex.Lock()
	defer fake.getByPhoneMutex.Unlock()
	fake.GetByPhoneStub = nil
	fake.getByPhoneReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByPhoneReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.getByPhoneMutex.Lock()
	defer fake.getByPhoneMutex.Unlock()
	fake.GetByPhoneStub = nil
	if fake.getByPhoneReturnsOnCall == nil {
		fake.getByPhoneReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.getByPhoneReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByUUID(arg1 uuid.UUID) (*models.User, error) {
	fake.getByUUIDMutex.Lock()
	ret, specificReturn := fake.getByUUIDReturnsOnCall[len(fake.getByUUIDArgsForCall)]
	fake.getByUUIDArgsForCall = append(fake.getByUUIDArgsForCall, struct {
		arg1 uuid.UUID
	}{arg1})
	fake.recordInvocation("GetByUUID", []interface{}{arg1})
	fake.getByUUIDMutex.Unlock()
	if fake.GetByUUIDStub != nil {
		return fake.GetByUUIDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getByUUIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetByUUIDCallCount() int {
	fake.getByUUIDMutex.RLock()
	defer fake.getByUUIDMutex.RUnlock()
	return len(fake.getByUUIDArgsForCall)
}

func (fake *FakeUserRepository) GetByUUIDCalls(stub func(uuid.UUID) (*models.User, error)) {
	fake.getByUUIDMutex.Lock()
	defer fake.getByUUIDMutex.Unlock()
	fake.GetByUUIDStub = stub
}

func (fake *FakeUserRepository) GetByUUIDArgsForCall(i int) uuid.UUID {
	fake.getByUUIDMutex.RLock()
	defer fake.getByUUIDMutex.RUnlock()
	argsForCall := fake.getByUUIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetByUUIDReturns(result1 *models.User, result2 error) {
	fake.getByUUIDMutex.Lock()
	defer fake.getByUUIDMutex.Unlock()
	fake.GetByUUIDStub = nil
	fake.getByUUIDReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetByUUIDReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.getByUUIDMutex.Lock()
	defer fake.getByUUIDMutex.Unlock()
	fake.GetByUUIDStub = nil
	if fake.getByUUIDReturnsOnCall == nil {
		fake.getByUUIDReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.getByUUIDReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetIngredients(arg1 int64) ([]*models.UserIngredient, error) {
	fake.getIngredientsMutex.Lock()
	ret, specificReturn := fake.getIngredientsReturnsOnCall[len(fake.getIngredientsArgsForCall)]
	fake.getIngredientsArgsForCall = append(fake.getIngredientsArgsForCall, struct {
		arg1 int64
	}{arg1})
	fake.recordInvocation("GetIngredients", []interface{}{arg1})
	fake.getIngredientsMutex.Unlock()
	if fake.GetIngredientsStub != nil {
		return fake.GetIngredientsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getIngredientsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetIngredientsCallCount() int {
	fake.getIngredientsMutex.RLock()
	defer fake.getIngredientsMutex.RUnlock()
	return len(fake.getIngredientsArgsForCall)
}

func (fake *FakeUserRepository) GetIngredientsCalls(stub func(int64) ([]*models.UserIngredient, error)) {
	fake.getIngredientsMutex.Lock()
	defer fake.getIngredientsMutex.Unlock()
	fake.GetIngredientsStub = stub
}

func (fake *FakeUserRepository) GetIngredientsArgsForCall(i int) int64 {
	fake.getIngredientsMutex.RLock()
	defer fake.getIngredientsMutex.RUnlock()
	argsForCall := fake.getIngredientsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetIngredientsReturns(result1 []*models.UserIngredient, result2 error) {
	fake.getIngredientsMutex.Lock()
	defer fake.getIngredientsMutex.Unlock()
	fake.GetIngredientsStub = nil
	fake.getIngredientsReturns = struct {
		result1 []*models.UserIngredient
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetIngredientsReturnsOnCall(i int, result1 []*models.UserIngredient, result2 error) {
	fake.getIngredientsMutex.Lock()
	defer fake.getIngredientsMutex.Unlock()
	fake.GetIngredientsStub = nil
	if fake.getIngredientsReturnsOnCall == nil {
		fake.getIngredientsReturnsOnCall = make(map[int]struct {
			result1 []*models.UserIngredient
			result2 error
		})
	}
	fake.getIngredientsReturnsOnCall[i] = struct {
		result1 []*models.UserIngredient
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetPermissions(arg1 int) ([]models.UserPermission, error) {
	fake.getPermissionsMutex.Lock()
	ret, specificReturn := fake.getPermissionsReturnsOnCall[len(fake.getPermissionsArgsForCall)]
	fake.getPermissionsArgsForCall = append(fake.getPermissionsArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("GetPermissions", []interface{}{arg1})
	fake.getPermissionsMutex.Unlock()
	if fake.GetPermissionsStub != nil {
		return fake.GetPermissionsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPermissionsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) GetPermissionsCallCount() int {
	fake.getPermissionsMutex.RLock()
	defer fake.getPermissionsMutex.RUnlock()
	return len(fake.getPermissionsArgsForCall)
}

func (fake *FakeUserRepository) GetPermissionsCalls(stub func(int) ([]models.UserPermission, error)) {
	fake.getPermissionsMutex.Lock()
	defer fake.getPermissionsMutex.Unlock()
	fake.GetPermissionsStub = stub
}

func (fake *FakeUserRepository) GetPermissionsArgsForCall(i int) int {
	fake.getPermissionsMutex.RLock()
	defer fake.getPermissionsMutex.RUnlock()
	argsForCall := fake.getPermissionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) GetPermissionsReturns(result1 []models.UserPermission, result2 error) {
	fake.getPermissionsMutex.Lock()
	defer fake.getPermissionsMutex.Unlock()
	fake.GetPermissionsStub = nil
	fake.getPermissionsReturns = struct {
		result1 []models.UserPermission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) GetPermissionsReturnsOnCall(i int, result1 []models.UserPermission, result2 error) {
	fake.getPermissionsMutex.Lock()
	defer fake.getPermissionsMutex.Unlock()
	fake.GetPermissionsStub = nil
	if fake.getPermissionsReturnsOnCall == nil {
		fake.getPermissionsReturnsOnCall = make(map[int]struct {
			result1 []models.UserPermission
			result2 error
		})
	}
	fake.getPermissionsReturnsOnCall[i] = struct {
		result1 []models.UserPermission
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) Insert(arg1 uuid.UUID, arg2 models.NullString, arg3 models.NullString, arg4 models.NullString, arg5 string, arg6 int, arg7 string) (*models.User, error) {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		arg1 uuid.UUID
		arg2 models.NullString
		arg3 models.NullString
		arg4 models.NullString
		arg5 string
		arg6 int
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.recordInvocation("Insert", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.insertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeUserRepository) InsertCalls(stub func(uuid.UUID, models.NullString, models.NullString, models.NullString, string, int, string) (*models.User, error)) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = stub
}

func (fake *FakeUserRepository) InsertArgsForCall(i int) (uuid.UUID, models.NullString, models.NullString, models.NullString, string, int, string) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	argsForCall := fake.insertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeUserRepository) InsertReturns(result1 *models.User, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) InsertReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) List(arg1 int, arg2 int, arg3 string) ([]*models.User, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("List", []interface{}{arg1, arg2, arg3})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeUserRepository) ListCalls(stub func(int, int, string) ([]*models.User, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeUserRepository) ListArgsForCall(i int) (int, int, string) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserRepository) ListReturns(result1 []*models.User, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []*models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) ListReturnsOnCall(i int, result1 []*models.User, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 []*models.User
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 []*models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) RemoveAllPermissions(arg1 int) error {
	fake.removeAllPermissionsMutex.Lock()
	ret, specificReturn := fake.removeAllPermissionsReturnsOnCall[len(fake.removeAllPermissionsArgsForCall)]
	fake.removeAllPermissionsArgsForCall = append(fake.removeAllPermissionsArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("RemoveAllPermissions", []interface{}{arg1})
	fake.removeAllPermissionsMutex.Unlock()
	if fake.RemoveAllPermissionsStub != nil {
		return fake.RemoveAllPermissionsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeAllPermissionsReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) RemoveAllPermissionsCallCount() int {
	fake.removeAllPermissionsMutex.RLock()
	defer fake.removeAllPermissionsMutex.RUnlock()
	return len(fake.removeAllPermissionsArgsForCall)
}

func (fake *FakeUserRepository) RemoveAllPermissionsCalls(stub func(int) error) {
	fake.removeAllPermissionsMutex.Lock()
	defer fake.removeAllPermissionsMutex.Unlock()
	fake.RemoveAllPermissionsStub = stub
}

func (fake *FakeUserRepository) RemoveAllPermissionsArgsForCall(i int) int {
	fake.removeAllPermissionsMutex.RLock()
	defer fake.removeAllPermissionsMutex.RUnlock()
	argsForCall := fake.removeAllPermissionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) RemoveAllPermissionsReturns(result1 error) {
	fake.removeAllPermissionsMutex.Lock()
	defer fake.removeAllPermissionsMutex.Unlock()
	fake.RemoveAllPermissionsStub = nil
	fake.removeAllPermissionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) RemoveAllPermissionsReturnsOnCall(i int, result1 error) {
	fake.removeAllPermissionsMutex.Lock()
	defer fake.removeAllPermissionsMutex.Unlock()
	fake.RemoveAllPermissionsStub = nil
	if fake.removeAllPermissionsReturnsOnCall == nil {
		fake.removeAllPermissionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllPermissionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) RemovePermission(arg1 int) (bool, error) {
	fake.removePermissionMutex.Lock()
	ret, specificReturn := fake.removePermissionReturnsOnCall[len(fake.removePermissionArgsForCall)]
	fake.removePermissionArgsForCall = append(fake.removePermissionArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("RemovePermission", []interface{}{arg1})
	fake.removePermissionMutex.Unlock()
	if fake.RemovePermissionStub != nil {
		return fake.RemovePermissionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.removePermissionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) RemovePermissionCallCount() int {
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	return len(fake.removePermissionArgsForCall)
}

func (fake *FakeUserRepository) RemovePermissionCalls(stub func(int) (bool, error)) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = stub
}

func (fake *FakeUserRepository) RemovePermissionArgsForCall(i int) int {
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	argsForCall := fake.removePermissionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) RemovePermissionReturns(result1 bool, result2 error) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = nil
	fake.removePermissionReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) RemovePermissionReturnsOnCall(i int, result1 bool, result2 error) {
	fake.removePermissionMutex.Lock()
	defer fake.removePermissionMutex.Unlock()
	fake.RemovePermissionStub = nil
	if fake.removePermissionReturnsOnCall == nil {
		fake.removePermissionReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.removePermissionReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) RemoveUserIngredient(arg1 int64) error {
	fake.removeUserIngredientMutex.Lock()
	ret, specificReturn := fake.removeUserIngredientReturnsOnCall[len(fake.removeUserIngredientArgsForCall)]
	fake.removeUserIngredientArgsForCall = append(fake.removeUserIngredientArgsForCall, struct {
		arg1 int64
	}{arg1})
	fake.recordInvocation("RemoveUserIngredient", []interface{}{arg1})
	fake.removeUserIngredientMutex.Unlock()
	if fake.RemoveUserIngredientStub != nil {
		return fake.RemoveUserIngredientStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeUserIngredientReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) RemoveUserIngredientCallCount() int {
	fake.removeUserIngredientMutex.RLock()
	defer fake.removeUserIngredientMutex.RUnlock()
	return len(fake.removeUserIngredientArgsForCall)
}

func (fake *FakeUserRepository) RemoveUserIngredientCalls(stub func(int64) error) {
	fake.removeUserIngredientMutex.Lock()
	defer fake.removeUserIngredientMutex.Unlock()
	fake.RemoveUserIngredientStub = stub
}

func (fake *FakeUserRepository) RemoveUserIngredientArgsForCall(i int) int64 {
	fake.removeUserIngredientMutex.RLock()
	defer fake.removeUserIngredientMutex.RUnlock()
	argsForCall := fake.removeUserIngredientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) RemoveUserIngredientReturns(result1 error) {
	fake.removeUserIngredientMutex.Lock()
	defer fake.removeUserIngredientMutex.Unlock()
	fake.RemoveUserIngredientStub = nil
	fake.removeUserIngredientReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) RemoveUserIngredientReturnsOnCall(i int, result1 error) {
	fake.removeUserIngredientMutex.Lock()
	defer fake.removeUserIngredientMutex.Unlock()
	fake.RemoveUserIngredientStub = nil
	if fake.removeUserIngredientReturnsOnCall == nil {
		fake.removeUserIngredientReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeUserIngredientReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SaveAuthToken(arg1 string, arg2 int) error {
	fake.saveAuthTokenMutex.Lock()
	ret, specificReturn := fake.saveAuthTokenReturnsOnCall[len(fake.saveAuthTokenArgsForCall)]
	fake.saveAuthTokenArgsForCall = append(fake.saveAuthTokenArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("SaveAuthToken", []interface{}{arg1, arg2})
	fake.saveAuthTokenMutex.Unlock()
	if fake.SaveAuthTokenStub != nil {
		return fake.SaveAuthTokenStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveAuthTokenReturns
	return fakeReturns.result1
}

func (fake *FakeUserRepository) SaveAuthTokenCallCount() int {
	fake.saveAuthTokenMutex.RLock()
	defer fake.saveAuthTokenMutex.RUnlock()
	return len(fake.saveAuthTokenArgsForCall)
}

func (fake *FakeUserRepository) SaveAuthTokenCalls(stub func(string, int) error) {
	fake.saveAuthTokenMutex.Lock()
	defer fake.saveAuthTokenMutex.Unlock()
	fake.SaveAuthTokenStub = stub
}

func (fake *FakeUserRepository) SaveAuthTokenArgsForCall(i int) (string, int) {
	fake.saveAuthTokenMutex.RLock()
	defer fake.saveAuthTokenMutex.RUnlock()
	argsForCall := fake.saveAuthTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserRepository) SaveAuthTokenReturns(result1 error) {
	fake.saveAuthTokenMutex.Lock()
	defer fake.saveAuthTokenMutex.Unlock()
	fake.SaveAuthTokenStub = nil
	fake.saveAuthTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) SaveAuthTokenReturnsOnCall(i int, result1 error) {
	fake.saveAuthTokenMutex.Lock()
	defer fake.saveAuthTokenMutex.Unlock()
	fake.SaveAuthTokenStub = nil
	if fake.saveAuthTokenReturnsOnCall == nil {
		fake.saveAuthTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveAuthTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserRepository) Update(arg1 *models.User) (*models.User, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *models.User
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserRepository) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeUserRepository) UpdateCalls(stub func(*models.User) (*models.User, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeUserRepository) UpdateArgsForCall(i int) *models.User {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserRepository) UpdateReturns(result1 *models.User, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) UpdateReturnsOnCall(i int, result1 *models.User, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *models.User
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *models.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addIngredientMutex.RLock()
	defer fake.addIngredientMutex.RUnlock()
	fake.addPermissionMutex.RLock()
	defer fake.addPermissionMutex.RUnlock()
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getByAuthTokenMutex.RLock()
	defer fake.getByAuthTokenMutex.RUnlock()
	fake.getByCredentialsMutex.RLock()
	defer fake.getByCredentialsMutex.RUnlock()
	fake.getByPhoneMutex.RLock()
	defer fake.getByPhoneMutex.RUnlock()
	fake.getByUUIDMutex.RLock()
	defer fake.getByUUIDMutex.RUnlock()
	fake.getIngredientsMutex.RLock()
	defer fake.getIngredientsMutex.RUnlock()
	fake.getPermissionsMutex.RLock()
	defer fake.getPermissionsMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.removeAllPermissionsMutex.RLock()
	defer fake.removeAllPermissionsMutex.RUnlock()
	fake.removePermissionMutex.RLock()
	defer fake.removePermissionMutex.RUnlock()
	fake.removeUserIngredientMutex.RLock()
	defer fake.removeUserIngredientMutex.RUnlock()
	fake.saveAuthTokenMutex.RLock()
	defer fake.saveAuthTokenMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ models.UserRepository = new(FakeUserRepository)
